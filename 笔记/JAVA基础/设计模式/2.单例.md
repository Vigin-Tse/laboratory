# 一. 单例模式的定义与特点



**定义**：指一个类**只有一个实例**，且**该类**能**自行创建这个实例**。

J2EE标准中的 **ServletContext** 和 **ServletContextConfig**、**Spring**框架应用中的 **ApplicationContext**、**数据库中的连接池**等都是单例模式。



**特点**：

1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点；

# 二. 优点和缺点

**优点**：

- 保证内存只有一个实例，减少内存开销。
- 避免资源的多重占用。
- 优化对共享资源的访问。

**缺点**：

- 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。
- 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。
- 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。



# 三. 应用场景

- 需要频繁创建的一些类，使用单例模式降低内存压力，减少GC。
- 某个类只需要生产一个对象的时候。
- 某些类实例时占用资源比较多，或者实例耗时比较长而且经常使用。
- 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
- 频繁访问数据库或文件的对象。
- 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。



# 四. 单例的实现

singleton的两种实现方式。

## 1.懒汉式单例

```java
public class LazySingleton {

    /**
     * volatile字段禁止多线程读取缓存，保存多线程环境下变量的可见性
     */
    private static volatile LazySingleton INSTANCE = null;

    /**
     * 构造函数访问权限设置private，表示该对象只能在内部创建，避免在类外部被实例化
     */
    private LazySingleton(){}

    /**
     * 外部获取实例只能通过这个方法
     * synchronized 保证在并发环境下只实例一次对象
     * @return
     */
    static synchronized LazySingleton getInstance(){

        //等第一次获取时才实例对象
        if (INSTANCE == null){
            INSTANCE = new LazySingleton();
        }

        return INSTANCE;
    }
}
```



## 2.饿汉式单例

```java
public class HungrySingleton {

    /**
     * 该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。
     */
    private static final HungrySingleton INSTANCE = new HungrySingleton();

    private HungrySingleton(){}

    /**
     * 饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。
     * @return
     */
    public static HungrySingleton getInstance(){
        return INSTANCE;
    }
}
```

