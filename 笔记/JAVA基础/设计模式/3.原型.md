# 一. 定义与特点

**定义：**

用一个**已经创建的实例作为原型**，通过**复制**该原型对象来创建一个和原型**相同或相似的新对象**。用这种方式**创建对象非常高效**，根本**无须知道**对象**创建的细节**。

# 二. 优点与缺点

**优点：**

- Java自带的原型模式基于二进制流的复制，在性能上比直接new一个对象更加优良。
- 可以使用深克隆方式保存对象状态，使用原型模式将对象复制一份，并将其状态保存起来，简化创建对象的过程，以便在需要的时候使用（例如恢复到历史的某一状态），可辅助实现撤销操作。

**缺点：**

- 需要为每一个类都配置一个clone方法。
- clone方法位于类的内部，当对已有的类进行改造的时候，需要修改代码，违背开闭原则。
- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为实现深克隆，每一层对象对应的类必须支持深克隆，实现起来比较麻烦。因此，深克隆、浅克隆需要运用得当。





# 三. 应用场景

原型模式通常适用于以下场景。

- 对象之间相同或相似，即只是个别的几个属性不同的时候。
- 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
- 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
- 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。



# 四. 结构与实现

java 提供了对象的 **clone()方法**，所以用java实现原型模式很简单。



## 1.  模式的结构

原型模式包含以下主要角色。

1. 抽象原型类：规定了具体原型对象必须实现的（Cloneable）接口。

2. 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。

3. 访问类：使用具体原型类中的 clone() 方法来复制新的对象

   

## 2.  模式分类

原型模式的克隆分为浅克隆和深克隆。

- ### 浅克隆

  创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。

- ### 深克隆

  创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。



## 3.  实现



### 3.1  浅克隆



####  代码样例

(成员对象类)ShollowCloneExpand.java

```java
@Getter
@Setter
public class ShollowCloneExpand {

    /**
     * 街道
     */
    private String address;

    /**
     * 门牌号
     */
    private int no;

    public ShollowCloneExpand(String address, int no){
        System.out.println("地址信息构造方法调用");
        this.address = address;
        this.no = no;
    }

}
```

(具体原型类)ShollowClone.java

```java
@Getter
@Setter
public class ShollowClone implements Cloneable {

    /**
     * 名称
     */
    private String name;

    /**
     * 年龄
     */
    private int age;

    /**
     * 地址信息
     */
    private ShollowCloneExpand address;

    public ShollowClone(String name, int age, ShollowCloneExpand address){
        System.out.println("个人基本信息构造方法调用");
        this.name = name;
        this.age = age;
        this.address = address;
    }

    @Override
    public ShollowClone clone() throws CloneNotSupportedException{
        System.out.println("peter被复制了");
        return (ShollowClone) super.clone();
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        /**
         * peter 个人信息
         */
        ShollowCloneExpand peterAddress = new ShollowCloneExpand("广州越秀东风路", 115);
        ShollowClone peter = new ShollowClone("peter", 18, peterAddress);

        /**
         * 复制 peter哥哥 个人信息
         */
        ShollowClone peterBigBrother = peter.clone();
        peterBigBrother.setName("bigBrother");
        peterBigBrother.setAge(19);
        peterBigBrother.getAddress().setAddress("广州越秀建设南路");
        peterBigBrother.getAddress().setNo(30);

        System.out.println("===================复制结果===================");
        System.out.println("是否同一个人：" + (peter == peterBigBrother) + "-----新对象引用与旧对象引用是否值指向同一内存地址");
        System.out.println("哥哥年纪比peter大" +   "，哥哥（" + peterBigBrother.getAge() + ")，peter(" + peter.getAge() + ")：" +(peterBigBrother.getAge() > peter.getAge()) + "-----修改新对象的基本属性，并不会影响原对象的基本属性");
        System.out.println("弟弟随哥哥搬家了，新地址=" + peter.getAddress().getAddress() + peter.getAddress().getNo() + "：" + (peter.getAddress() == peterBigBrother.getAddress()) + "-----非基本类型属性，仍指向原有属性所指向的对象的内存地址");
    }
```

####  运行结果

![1604655103(1)](.\pic\1604655216(1).jpg)



####  总结

实现浅克隆遵循以下几点：

- 重写**Object类的clone方法**，并且实现**Cloneable接口**（标识接口，无需实现任何方法） 。
- **基本变量类型（成员）**会**复制相同值**，而**引用变量类型（成员）**会**复制相同的引用**。
- 浅克隆**不会调用构造方法**。





### 3.2 深克隆

简单点说**浅克隆是一个不完善的克隆**，内部**引用变量类型**成员没有完成克隆复制，从而造成克隆者与被克隆对象的**数据没有完全分离**产生数据交叉混乱的问题。深克隆就是解决浅克隆的问题。



#### 3.2.1 实现一：对象成员重写clone方法

##### 代码样例

DeepCloneStudentExample1.java

```java
/**
 * @description: 深克隆成员对象类（继承cloneable方式）
 * @author: xieweij
 * @create: 2020-11-10 14:54
 **/
@Setter
@Getter
public class DeepCloneStudentExample1 implements Cloneable {

    private String name;

    private int age;

    public DeepCloneStudentExample1(String name, int age){
        this.name = name;
        this.age = age;
    }

    /**
     * 克隆对象的引用成员实现Cloneable接口并重写clone方法，引用变量也能进行克隆（开辟新内存）
     * @return
     */
    @Override
    public DeepCloneStudentExample1 clone() throws CloneNotSupportedException {
        return (DeepCloneStudentExample1)super.clone();
    }
}
```



DeepCloneTeacherExample1.java

```java
/**
 * @description: 深克隆（实现cloneable方式）
 * @author: xieweij
 * @create: 2020-11-10 14:57
 **/
@Setter
@Getter
public class DeepCloneTeacherExample1 implements Cloneable {

    private String name;

    private int age;

    private DeepCloneStudentExample1 student;

    public DeepCloneTeacherExample1(String name, int age,  DeepCloneStudentExample1 student){
        this.name = name;
        this.age = age;
        this.student = student;
    }

    @Override
    public DeepCloneTeacherExample1 clone() throws CloneNotSupportedException {
        System.out.println("老师被复制了");
        DeepCloneTeacherExample1 t = null;
        t = (DeepCloneTeacherExample1)super.clone();
        t.student = (DeepCloneStudentExample1) this.student.clone();
        return t;
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        DeepCloneStudentExample1 student1 = new DeepCloneStudentExample1("小明", 18);
        DeepCloneTeacherExample1 teacher1 = new DeepCloneTeacherExample1("李老师", 32, student1);

        DeepCloneTeacherExample1 teacher2 = teacher1.clone();
        System.out.println("引用成员共用同一内存：" + (teacher1.getStudent() == teacher2.getStudent()));
    }
}
```



##### 运行结果

![](.\pic\1605146000.jpg)



##### 总结

克隆对象的引用类型变量对象实现Cloneable接口并重写clone方法，（引用变量）会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。





#### 实现二：对象序列化

虽然层次调用clone方法可以实现深拷贝，但是显然代码量实在太大。特别对于属性数量比较多、层次比较深的类而言，每个类都要重写clone方法太过繁琐。将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。



##### 代码样例

DeepCloneStudentExample2.java

```java
@Getter
@Setter
public class DeepCloneStudentExample2 implements Serializable {

    private String name;

    private int age;

    public DeepCloneStudentExample2(String name, int age){
        this.name = name;
        this.age = age;
    }
}
```



DeepCloneTeacherExample2.java

```java
@Getter
@Setter
public class DeepCloneTeacherExample2 implements Serializable {

    private String name;

    private int age;

    private DeepCloneStudentExample2 student;

    public DeepCloneTeacherExample2(String name, int age,  DeepCloneStudentExample2 student){
        this.name = name;
        this.age = age;
        this.student = student;
    }

    /**
     * 序列化克隆方式
     * @return
     */
    public DeepCloneTeacherExample2 clone(){
        DeepCloneTeacherExample2 teacher = null;

        try {
            // 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(this);
            oos.close();


            //将流反序列化成对象
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            teacher = (DeepCloneTeacherExample2) ois.readObject();

            ois.close();
            baos.close();
            bais.close();

        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        return teacher;
    }

    public static void main(String[] args){
        DeepCloneStudentExample2 stu = new DeepCloneStudentExample2("小李", 12);
        DeepCloneTeacherExample2 tecLiu = new DeepCloneTeacherExample2("刘老师", 28, stu);

        DeepCloneTeacherExample2 tecLiu2 = tecLiu.clone();

        System.out.println(JSON.toJSONString(tecLiu));
        System.out.println(JSON.toJSONString(tecLiu2));
        System.out.println("（内存空间是否一样）老师是否同一个：" + (tecLiu == tecLiu2));
        System.out.println("（内存空间是否一样）学生是否同一个：" + (tecLiu.getStudent() == tecLiu2.getStudent()));
    }
}
```



##### 运行结果

![1605159663](.\pic\1605159663.jpg)



##### 总结

- **序列化**：把对象写到流里
- **反序列化**：把对象从流中读出来

**在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。**

**注意：**

- `写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面`。
- `对象以及对象内部所有引用到的对象都是可序列化的`
- `如果不想序列化，则需要使用transient来修饰`

